{"ast":null,"code":"import { peerIdFromString } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { SendingQuery, PeerResponse, FinalPeer, QueryError, Provider, Value, AddingPeer, DialingPeer } from './response-types.js';\nexport function mapEvent(event) {\n  if (event.Type === SendingQuery) {\n    return {\n      name: 'SENDING_QUERY',\n      type: event.Type\n    };\n  }\n  if (event.Type === PeerResponse) {\n    return {\n      from: peerIdFromString(event.ID),\n      name: 'PEER_RESPONSE',\n      type: event.Type,\n      // TODO: how to infer this from the go-ipfs response\n      messageType: 0,\n      // TODO: how to infer this from the go-ipfs response\n      messageName: 'PUT_VALUE',\n      closer: (event.Responses ?? []).map(({\n        ID,\n        Addrs\n      }) => ({\n        id: peerIdFromString(ID),\n        multiaddrs: Addrs.map(addr => multiaddr(addr)),\n        protocols: []\n      })),\n      providers: (event.Responses ?? []).map(({\n        ID,\n        Addrs\n      }) => ({\n        id: peerIdFromString(ID),\n        multiaddrs: Addrs.map(addr => multiaddr(addr)),\n        protocols: []\n      }))\n      // TODO: how to infer this from the go-ipfs response\n      // record: ???\n    };\n  }\n  if (event.Type === FinalPeer) {\n    // dht.query ends with a FinalPeer event with no Responses\n    /** @type {import('../types.js').PeerInfo} */\n    let peer = {\n      id: event.ID ?? peerIdFromString(event.ID),\n      /** @type {Multiaddr[]} */\n      multiaddrs: [],\n      protocols: []\n    };\n    if (event.Responses?.length > 0) {\n      // dht.findPeer has the result in the Responses field\n      peer = {\n        id: peerIdFromString(event.Responses[0].ID),\n        multiaddrs: event.Responses[0].Addrs.map(addr => multiaddr(addr)),\n        protocols: []\n      };\n    }\n    return {\n      name: 'FINAL_PEER',\n      type: event.Type,\n      peer\n    };\n  }\n  if (event.Type === QueryError) {\n    return {\n      name: 'QUERY_ERROR',\n      type: event.Type,\n      error: new Error(event.Extra)\n    };\n  }\n  if (event.Type === Provider) {\n    return {\n      name: 'PROVIDER',\n      type: event.Type,\n      providers: event.Responses.map(({\n        ID,\n        Addrs\n      }) => ({\n        id: peerIdFromString(ID),\n        multiaddrs: Addrs.map(addr => multiaddr(addr)),\n        protocols: []\n      }))\n    };\n  }\n  if (event.Type === Value) {\n    return {\n      name: 'VALUE',\n      type: event.Type,\n      value: uint8ArrayFromString(event.Extra, 'base64pad')\n    };\n  }\n  if (event.Type === AddingPeer) {\n    const peers = event.Responses.map(({\n      ID\n    }) => peerIdFromString(ID));\n    if (peers.length === 0) {\n      throw new Error('No peer found');\n    }\n    return {\n      name: 'ADDING_PEER',\n      type: event.Type,\n      peer: peers[0]\n    };\n  }\n  if (event.Type === DialingPeer) {\n    return {\n      name: 'DIALING_PEER',\n      type: event.Type,\n      peer: peerIdFromString(event.ID)\n    };\n  }\n  throw new Error('Unknown DHT event type');\n}","map":{"version":3,"names":["peerIdFromString","multiaddr","fromString","uint8ArrayFromString","SendingQuery","PeerResponse","FinalPeer","QueryError","Provider","Value","AddingPeer","DialingPeer","mapEvent","event","Type","name","type","from","ID","messageType","messageName","closer","Responses","map","Addrs","id","multiaddrs","addr","protocols","providers","peer","length","error","Error","Extra","value","peers"],"sources":["/home/lokesh/Desktop/DGovt.Services/Hack36_1/client/node_modules/kubo-rpc-client/src/dht/map-event.ts"],"sourcesContent":["import { peerIdFromString } from '@libp2p/peer-id'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport {\n  SendingQuery,\n  PeerResponse,\n  FinalPeer,\n  QueryError,\n  Provider,\n  Value,\n  AddingPeer,\n  DialingPeer\n} from './response-types.js'\nimport type { RoutingQueryEvent } from './index.js'\n\nexport function mapEvent (event: any): RoutingQueryEvent {\n  if (event.Type === SendingQuery) {\n    return {\n      name: 'SENDING_QUERY',\n      type: event.Type\n    }\n  }\n\n  if (event.Type === PeerResponse) {\n    return {\n      from: peerIdFromString(event.ID),\n      name: 'PEER_RESPONSE',\n      type: event.Type,\n      // TODO: how to infer this from the go-ipfs response\n      messageType: 0,\n      // TODO: how to infer this from the go-ipfs response\n      messageName: 'PUT_VALUE',\n      closer: (event.Responses ?? []).map(({ ID, Addrs }: any) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr: any) => multiaddr(addr)), protocols: [] })),\n      providers: (event.Responses ?? []).map(({ ID, Addrs }: any) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr: any) => multiaddr(addr)), protocols: [] }))\n      // TODO: how to infer this from the go-ipfs response\n      // record: ???\n    }\n  }\n\n  if (event.Type === FinalPeer) {\n    // dht.query ends with a FinalPeer event with no Responses\n    /** @type {import('../types.js').PeerInfo} */\n    let peer = {\n      id: event.ID ?? peerIdFromString(event.ID),\n      /** @type {Multiaddr[]} */\n      multiaddrs: [],\n      protocols: []\n    }\n\n    if (event.Responses?.length > 0) {\n      // dht.findPeer has the result in the Responses field\n      peer = {\n        id: peerIdFromString(event.Responses[0].ID),\n        multiaddrs: event.Responses[0].Addrs.map((addr: any) => multiaddr(addr)),\n        protocols: []\n      }\n    }\n\n    return {\n      name: 'FINAL_PEER',\n      type: event.Type,\n      peer\n    }\n  }\n\n  if (event.Type === QueryError) {\n    return {\n      name: 'QUERY_ERROR',\n      type: event.Type,\n      error: new Error(event.Extra)\n    }\n  }\n\n  if (event.Type === Provider) {\n    return {\n      name: 'PROVIDER',\n      type: event.Type,\n      providers: event.Responses.map(({ ID, Addrs }: any) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr: any) => multiaddr(addr)), protocols: [] }))\n    }\n  }\n\n  if (event.Type === Value) {\n    return {\n      name: 'VALUE',\n      type: event.Type,\n      value: uint8ArrayFromString(event.Extra, 'base64pad')\n    }\n  }\n\n  if (event.Type === AddingPeer) {\n    const peers = event.Responses.map(({ ID }: any) => peerIdFromString(ID))\n\n    if (peers.length === 0) {\n      throw new Error('No peer found')\n    }\n\n    return {\n      name: 'ADDING_PEER',\n      type: event.Type,\n      peer: peers[0]\n    }\n  }\n\n  if (event.Type === DialingPeer) {\n    return {\n      name: 'DIALING_PEER',\n      type: event.Type,\n      peer: peerIdFromString(event.ID)\n    }\n  }\n\n  throw new Error('Unknown DHT event type')\n}\n"],"mappings":"AAAA,SAASA,gBAAgB,QAAQ,iBAAiB;AAClD,SAASC,SAAS,QAAQ,yBAAyB;AACnD,SAASC,UAAU,IAAIC,oBAAoB,QAAQ,yBAAyB;AAC5E,SACEC,YAAY,EACZC,YAAY,EACZC,SAAS,EACTC,UAAU,EACVC,QAAQ,EACRC,KAAK,EACLC,UAAU,EACVC,WAAW,QACN,qBAAqB;AAG5B,OAAM,SAAUC,QAAQA,CAAEC,KAAU;EAClC,IAAIA,KAAK,CAACC,IAAI,KAAKV,YAAY,EAAE;IAC/B,OAAO;MACLW,IAAI,EAAE,eAAe;MACrBC,IAAI,EAAEH,KAAK,CAACC;KACb;EACH;EAEA,IAAID,KAAK,CAACC,IAAI,KAAKT,YAAY,EAAE;IAC/B,OAAO;MACLY,IAAI,EAAEjB,gBAAgB,CAACa,KAAK,CAACK,EAAE,CAAC;MAChCH,IAAI,EAAE,eAAe;MACrBC,IAAI,EAAEH,KAAK,CAACC,IAAI;MAChB;MACAK,WAAW,EAAE,CAAC;MACd;MACAC,WAAW,EAAE,WAAW;MACxBC,MAAM,EAAE,CAACR,KAAK,CAACS,SAAS,IAAI,EAAE,EAAEC,GAAG,CAAC,CAAC;QAAEL,EAAE;QAAEM;MAAK,CAAO,MAAM;QAAEC,EAAE,EAAEzB,gBAAgB,CAACkB,EAAE,CAAC;QAAEQ,UAAU,EAAEF,KAAK,CAACD,GAAG,CAAEI,IAAS,IAAK1B,SAAS,CAAC0B,IAAI,CAAC,CAAC;QAAEC,SAAS,EAAE;MAAE,CAAE,CAAC,CAAC;MACjKC,SAAS,EAAE,CAAChB,KAAK,CAACS,SAAS,IAAI,EAAE,EAAEC,GAAG,CAAC,CAAC;QAAEL,EAAE;QAAEM;MAAK,CAAO,MAAM;QAAEC,EAAE,EAAEzB,gBAAgB,CAACkB,EAAE,CAAC;QAAEQ,UAAU,EAAEF,KAAK,CAACD,GAAG,CAAEI,IAAS,IAAK1B,SAAS,CAAC0B,IAAI,CAAC,CAAC;QAAEC,SAAS,EAAE;MAAE,CAAE,CAAC;MACnK;MACA;KACD;EACH;EAEA,IAAIf,KAAK,CAACC,IAAI,KAAKR,SAAS,EAAE;IAC5B;IACA;IACA,IAAIwB,IAAI,GAAG;MACTL,EAAE,EAAEZ,KAAK,CAACK,EAAE,IAAIlB,gBAAgB,CAACa,KAAK,CAACK,EAAE,CAAC;MAC1C;MACAQ,UAAU,EAAE,EAAE;MACdE,SAAS,EAAE;KACZ;IAED,IAAIf,KAAK,CAACS,SAAS,EAAES,MAAM,GAAG,CAAC,EAAE;MAC/B;MACAD,IAAI,GAAG;QACLL,EAAE,EAAEzB,gBAAgB,CAACa,KAAK,CAACS,SAAS,CAAC,CAAC,CAAC,CAACJ,EAAE,CAAC;QAC3CQ,UAAU,EAAEb,KAAK,CAACS,SAAS,CAAC,CAAC,CAAC,CAACE,KAAK,CAACD,GAAG,CAAEI,IAAS,IAAK1B,SAAS,CAAC0B,IAAI,CAAC,CAAC;QACxEC,SAAS,EAAE;OACZ;IACH;IAEA,OAAO;MACLb,IAAI,EAAE,YAAY;MAClBC,IAAI,EAAEH,KAAK,CAACC,IAAI;MAChBgB;KACD;EACH;EAEA,IAAIjB,KAAK,CAACC,IAAI,KAAKP,UAAU,EAAE;IAC7B,OAAO;MACLQ,IAAI,EAAE,aAAa;MACnBC,IAAI,EAAEH,KAAK,CAACC,IAAI;MAChBkB,KAAK,EAAE,IAAIC,KAAK,CAACpB,KAAK,CAACqB,KAAK;KAC7B;EACH;EAEA,IAAIrB,KAAK,CAACC,IAAI,KAAKN,QAAQ,EAAE;IAC3B,OAAO;MACLO,IAAI,EAAE,UAAU;MAChBC,IAAI,EAAEH,KAAK,CAACC,IAAI;MAChBe,SAAS,EAAEhB,KAAK,CAACS,SAAS,CAACC,GAAG,CAAC,CAAC;QAAEL,EAAE;QAAEM;MAAK,CAAO,MAAM;QAAEC,EAAE,EAAEzB,gBAAgB,CAACkB,EAAE,CAAC;QAAEQ,UAAU,EAAEF,KAAK,CAACD,GAAG,CAAEI,IAAS,IAAK1B,SAAS,CAAC0B,IAAI,CAAC,CAAC;QAAEC,SAAS,EAAE;MAAE,CAAE,CAAC;KAC5J;EACH;EAEA,IAAIf,KAAK,CAACC,IAAI,KAAKL,KAAK,EAAE;IACxB,OAAO;MACLM,IAAI,EAAE,OAAO;MACbC,IAAI,EAAEH,KAAK,CAACC,IAAI;MAChBqB,KAAK,EAAEhC,oBAAoB,CAACU,KAAK,CAACqB,KAAK,EAAE,WAAW;KACrD;EACH;EAEA,IAAIrB,KAAK,CAACC,IAAI,KAAKJ,UAAU,EAAE;IAC7B,MAAM0B,KAAK,GAAGvB,KAAK,CAACS,SAAS,CAACC,GAAG,CAAC,CAAC;MAAEL;IAAE,CAAO,KAAKlB,gBAAgB,CAACkB,EAAE,CAAC,CAAC;IAExE,IAAIkB,KAAK,CAACL,MAAM,KAAK,CAAC,EAAE;MACtB,MAAM,IAAIE,KAAK,CAAC,eAAe,CAAC;IAClC;IAEA,OAAO;MACLlB,IAAI,EAAE,aAAa;MACnBC,IAAI,EAAEH,KAAK,CAACC,IAAI;MAChBgB,IAAI,EAAEM,KAAK,CAAC,CAAC;KACd;EACH;EAEA,IAAIvB,KAAK,CAACC,IAAI,KAAKH,WAAW,EAAE;IAC9B,OAAO;MACLI,IAAI,EAAE,cAAc;MACpBC,IAAI,EAAEH,KAAK,CAACC,IAAI;MAChBgB,IAAI,EAAE9B,gBAAgB,CAACa,KAAK,CAACK,EAAE;KAChC;EACH;EAEA,MAAM,IAAIe,KAAK,CAAC,wBAAwB,CAAC;AAC3C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}