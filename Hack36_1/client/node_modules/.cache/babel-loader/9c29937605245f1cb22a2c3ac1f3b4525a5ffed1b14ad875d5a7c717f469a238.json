{"ast":null,"code":"/* eslint-disable no-undef */\nimport { logger } from '@libp2p/logger';\nimport { anySignal } from 'any-signal';\nimport browserReableStreamToIt from 'browser-readablestream-to-it';\nimport { URL, URLSearchParams } from 'iso-url';\nimport all from 'it-all';\nimport mergeOpts from 'merge-options';\nimport { isBrowser, isWebWorker } from 'wherearewe';\nimport { TimeoutError, HTTPError } from './http/error.js';\nimport { fetch, Request, Headers } from './http/fetch.js';\nconst merge = mergeOpts.bind({\n  ignoreUndefined: true\n});\nconst log = logger('kubo-rpc-client:fetch');\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n};\nexport class HTTP {\n  static HTTPError = HTTPError;\n  static TimeoutError = TimeoutError;\n  static post = async (resource, options) => new HTTP(options).post(resource, options);\n  static get = async (resource, options) => new HTTP(options).get(resource, options);\n  static put = async (resource, options) => new HTTP(options).put(resource, options);\n  static delete = async (resource, options) => new HTTP(options).delete(resource, options);\n  static options = async (resource, options) => new HTTP(options).options(resource, options);\n  opts;\n  constructor(options = {}) {\n    this.opts = merge({}, defaults, options);\n  }\n  /**\n   * Fetch\n   */\n  async fetch(resource, options = {}) {\n    const opts = merge({}, this.opts, options);\n    const headers = new Headers(opts.headers);\n    // validate resource type\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    const url = new URL(resource.toString(), opts.base);\n    const {\n      searchParams,\n      transformSearchParams,\n      json\n    } = opts;\n    if (searchParams != null) {\n      if (typeof transformSearchParams === 'function') {\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams));\n      } else {\n        url.search = new URLSearchParams(opts.searchParams).toString();\n      }\n    }\n    if (json != null) {\n      opts.body = JSON.stringify(opts.json);\n      headers.set('content-type', 'application/json');\n    }\n    const signals = [opts.signal];\n    if (opts.timeout != null && isNaN(opts.timeout) && opts.timeout > 0) {\n      signals.push(AbortSignal.timeout(opts.timeout));\n    }\n    const signal = anySignal(signals);\n    try {\n      if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser || isWebWorker)) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1387483\n        opts.body = new Blob(await all(browserReableStreamToIt(opts.body)));\n      }\n      log.trace('outgoing headers', opts.headers);\n      log.trace('%s %s', opts.method, url);\n      // @ts-expect-error extra properties are added later\n      const response = await fetch(url.toString(), {\n        ...opts,\n        signal: opts.signal,\n        timeout: undefined,\n        headers,\n        // https://fetch.spec.whatwg.org/#dom-requestinit-duplex\n        // https://github.com/whatwg/fetch/issues/1254\n        duplex: 'half'\n      });\n      log('%s %s %d', opts.method, url, response.status);\n      log.trace('incoming headers', response.headers);\n      if (!response.ok && opts.throwHttpErrors === true) {\n        if (opts.handleError != null) {\n          await opts.handleError(response);\n        }\n        throw new HTTPError(response);\n      }\n      response.iterator = async function* () {\n        yield* fromStream(response.body);\n      };\n      response.ndjson = async function* () {\n        for await (const chunk of ndjson(response.iterator())) {\n          if (options.transform != null) {\n            yield options.transform(chunk);\n          } else {\n            yield chunk;\n          }\n        }\n      };\n      return response;\n    } finally {\n      signal.clear();\n    }\n  }\n  async post(resource, options = {}) {\n    return this.fetch(resource, {\n      ...options,\n      method: 'POST'\n    });\n  }\n  async get(resource, options = {}) {\n    return this.fetch(resource, {\n      ...options,\n      method: 'GET'\n    });\n  }\n  async put(resource, options = {}) {\n    return this.fetch(resource, {\n      ...options,\n      method: 'PUT'\n    });\n  }\n  async delete(resource, options = {}) {\n    return this.fetch(resource, {\n      ...options,\n      method: 'DELETE'\n    });\n  }\n  async options(resource, options = {}) {\n    return this.fetch(resource, {\n      ...options,\n      method: 'OPTIONS'\n    });\n  }\n}\n/**\n * Parses NDJSON chunks from an iterator\n */\nconst ndjson = async function* (source) {\n  const decoder = new TextDecoder();\n  let buf = '';\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, {\n      stream: true\n    });\n    const lines = buf.split(/\\r?\\n/);\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim();\n      if (l.length > 0) {\n        yield JSON.parse(l);\n      }\n    }\n    buf = lines[lines.length - 1];\n  }\n  buf += decoder.decode();\n  buf = buf.trim();\n  if (buf.length !== 0) {\n    yield JSON.parse(buf);\n  }\n};\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\nconst fromStream = source => {\n  if (isAsyncIterable(source)) {\n    return source;\n  }\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]();\n    return {\n      [Symbol.asyncIterator]() {\n        return {\n          next: iter.next.bind(iter),\n          return(value) {\n            source.destroy();\n            if (typeof iter.return === 'function') {\n              return iter.return();\n            }\n            return Promise.resolve({\n              done: true,\n              value\n            });\n          }\n        };\n      }\n    };\n  }\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader();\n    return async function* () {\n      try {\n        while (true) {\n          // Read from the stream\n          const {\n            done,\n            value\n          } = await reader.read();\n          // Exit if we're done\n          if (done) return;\n          // Else yield the chunk\n          if (value != null) {\n            yield value;\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    }();\n  }\n  throw new TypeError('Body can\\'t be converted to AsyncIterable');\n};\n/**\n * Check if it's an AsyncIterable\n */\nconst isAsyncIterable = value => {\n  return value !== null && typeof value[Symbol.asyncIterator] === 'function';\n};\n/**\n * Check for web readable stream\n */\nconst isWebReadableStream = value => {\n  return value != null && typeof value.getReader === 'function';\n};\n/**\n * Check for node readable stream\n */\nconst isNodeReadableStream = value => Object.prototype.hasOwnProperty.call(value, 'readable') && Object.prototype.hasOwnProperty.call(value, 'writable');","map":{"version":3,"names":["logger","anySignal","browserReableStreamToIt","URL","URLSearchParams","all","mergeOpts","isBrowser","isWebWorker","TimeoutError","HTTPError","fetch","Request","Headers","merge","bind","ignoreUndefined","log","defaults","throwHttpErrors","credentials","HTTP","post","resource","options","get","put","delete","opts","constructor","headers","TypeError","url","toString","base","searchParams","transformSearchParams","json","search","body","JSON","stringify","set","signals","signal","timeout","isNaN","push","AbortSignal","globalThis","ReadableStream","Blob","trace","method","response","undefined","duplex","status","ok","handleError","iterator","fromStream","ndjson","chunk","transform","clear","source","decoder","TextDecoder","buf","decode","stream","lines","split","i","length","l","trim","parse","isAsyncIterable","isNodeReadableStream","iter","Symbol","asyncIterator","next","return","value","destroy","Promise","resolve","done","isWebReadableStream","reader","getReader","read","releaseLock","Object","prototype","hasOwnProperty","call"],"sources":["/home/lokesh/Desktop/DGovt.Services/Hack36_1/client/node_modules/kubo-rpc-client/src/lib/http.ts"],"sourcesContent":["/* eslint-disable no-undef */\n\nimport { logger } from '@libp2p/logger'\nimport { anySignal } from 'any-signal'\nimport browserReableStreamToIt from 'browser-readablestream-to-it'\nimport { URL, URLSearchParams } from 'iso-url'\nimport all from 'it-all'\nimport mergeOpts from 'merge-options'\nimport { isBrowser, isWebWorker } from 'wherearewe'\nimport { TimeoutError, HTTPError } from './http/error.js'\nimport { fetch, Request, Headers } from './http/fetch.js'\nimport type { UploadProgressFn } from '../index.js'\nimport type { Readable } from 'node:stream'\n\nconst merge = mergeOpts.bind({ ignoreUndefined: true })\n\nconst log = logger('kubo-rpc-client:fetch')\n\ntype Override<T, R> = Omit<T, keyof R> & R\n\nexport type FetchOptions = Override<RequestInit, {\n  /**\n   * Amount of time until request should timeout in ms.\n   */\n  timeout?: number | string\n  /**\n   * URL search param.\n   */\n  searchParams?: URLSearchParams\n  /**\n   * Can be passed to track upload progress.\n   * Note that if this option in passed underlying request will be performed using `XMLHttpRequest` and response will not be streamed.\n   */\n  onUploadProgress?: UploadProgressFn\n  /**\n   * Can be passed to track download progress.\n   */\n  onDownloadProgress?: UploadProgressFn\n  overrideMimeType?: string\n}>\n\nexport interface HTTPOptions extends FetchOptions {\n  json?: any\n  /**\n   * The base URL to use in case url is a relative URL\n   */\n  base?: string\n  /**\n   * Throw not ok responses as Errors\n   */\n  throwHttpErrors?: boolean\n  /**\n   * Transform search params\n   */\n  transformSearchParams?(params: URLSearchParams): URLSearchParams\n  /**\n   * When iterating the response body, transform each chunk with this function.\n   */\n  transform?(chunk: any): any\n  /**\n   * Handle errors\n   */\n  handleError?(rsp: Response): Promise<void>\n  /**\n   * Control request creation\n   */\n  agent?: any\n}\n\nexport interface ExtendedResponse extends Response {\n  iterator(): AsyncGenerator<Uint8Array, void, undefined>\n\n  ndjson(): AsyncGenerator<any, void, undefined>\n}\n\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n}\n\nexport class HTTP {\n  static HTTPError = HTTPError\n  static TimeoutError = TimeoutError\n\n  static post = async (resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse> => new HTTP(options).post(resource, options)\n  static get = async (resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse> => new HTTP(options).get(resource, options)\n  static put = async (resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse> => new HTTP(options).put(resource, options)\n  static delete = async (resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse> => new HTTP(options).delete(resource, options)\n  static options = async (resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse> => new HTTP(options).options(resource, options)\n\n  public readonly opts: HTTPOptions\n\n  constructor (options: HTTPOptions = {}) {\n    this.opts = merge({}, defaults, options)\n  }\n\n  /**\n   * Fetch\n   */\n  async fetch (resource: string | Request, options: HTTPOptions = {}): Promise<ExtendedResponse> {\n    const opts = merge({}, this.opts, options)\n    const headers = new Headers(opts.headers)\n\n    // validate resource type\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request')\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    const url = new URL(resource.toString(), opts.base)\n\n    const {\n      searchParams,\n      transformSearchParams,\n      json\n    } = opts\n\n    if (searchParams != null) {\n      if (typeof transformSearchParams === 'function') {\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams))\n      } else {\n        url.search = new URLSearchParams(opts.searchParams).toString()\n      }\n    }\n\n    if (json != null) {\n      opts.body = JSON.stringify(opts.json)\n      headers.set('content-type', 'application/json')\n    }\n\n    const signals = [opts.signal]\n\n    if (opts.timeout != null && isNaN(opts.timeout) && opts.timeout > 0) {\n      signals.push(AbortSignal.timeout(opts.timeout))\n    }\n\n    const signal = anySignal(signals)\n\n    try {\n      if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser || isWebWorker)) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1387483\n        opts.body = new Blob(await all(browserReableStreamToIt<Uint8Array>(opts.body)))\n      }\n\n      log.trace('outgoing headers', opts.headers)\n      log.trace('%s %s', opts.method, url)\n\n      // @ts-expect-error extra properties are added later\n      const response: ExtendedResponse = await fetch(url.toString(), {\n        ...opts,\n        signal: opts.signal,\n        timeout: undefined,\n        headers,\n\n        // https://fetch.spec.whatwg.org/#dom-requestinit-duplex\n        // https://github.com/whatwg/fetch/issues/1254\n        duplex: 'half'\n      })\n\n      log('%s %s %d', opts.method, url, response.status)\n      log.trace('incoming headers', response.headers)\n\n      if (!response.ok && opts.throwHttpErrors === true) {\n        if (opts.handleError != null) {\n          await opts.handleError(response)\n        }\n        throw new HTTPError(response)\n      }\n\n      response.iterator = async function * () {\n        yield * fromStream(response.body)\n      }\n\n      response.ndjson = async function * () {\n        for await (const chunk of ndjson(response.iterator())) {\n          if (options.transform != null) {\n            yield options.transform(chunk)\n          } else {\n            yield chunk\n          }\n        }\n      }\n\n      return response\n    } finally {\n      signal.clear()\n    }\n  }\n\n  async post (resource: string | Request, options: HTTPOptions = {}): Promise<ExtendedResponse> {\n    return this.fetch(resource, { ...options, method: 'POST' })\n  }\n\n  async get (resource: string | Request, options: HTTPOptions = {}): Promise<ExtendedResponse> {\n    return this.fetch(resource, { ...options, method: 'GET' })\n  }\n\n  async put (resource: string | Request, options: HTTPOptions = {}): Promise<ExtendedResponse> {\n    return this.fetch(resource, { ...options, method: 'PUT' })\n  }\n\n  async delete (resource: string | Request, options: HTTPOptions = {}): Promise<ExtendedResponse> {\n    return this.fetch(resource, { ...options, method: 'DELETE' })\n  }\n\n  async options (resource: string | Request, options: HTTPOptions = {}): Promise<ExtendedResponse> {\n    return this.fetch(resource, { ...options, method: 'OPTIONS' })\n  }\n}\n\n/**\n * Parses NDJSON chunks from an iterator\n */\nconst ndjson = async function * (source: AsyncIterable<Uint8Array>): AsyncIterable<any> {\n  const decoder = new TextDecoder()\n  let buf = ''\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, { stream: true })\n    const lines = buf.split(/\\r?\\n/)\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim()\n      if (l.length > 0) {\n        yield JSON.parse(l)\n      }\n    }\n    buf = lines[lines.length - 1]\n  }\n  buf += decoder.decode()\n  buf = buf.trim()\n  if (buf.length !== 0) {\n    yield JSON.parse(buf)\n  }\n}\n\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\nconst fromStream = <TChunk> (source: ReadableStream<TChunk> | Readable | null): AsyncIterable<TChunk> => {\n  if (isAsyncIterable(source)) {\n    return source\n  }\n\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]()\n    return {\n      [Symbol.asyncIterator] () {\n        return {\n          next: iter.next.bind(iter),\n          return (value: any): any {\n            source.destroy()\n            if (typeof iter.return === 'function') {\n              return iter.return()\n            }\n            return Promise.resolve({ done: true, value })\n          }\n        }\n      }\n    }\n  }\n\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader()\n    return (async function * () {\n      try {\n        while (true) {\n          // Read from the stream\n          const { done, value } = await reader.read()\n          // Exit if we're done\n          if (done) return\n          // Else yield the chunk\n          if (value != null) {\n            yield value\n          }\n        }\n      } finally {\n        reader.releaseLock()\n      }\n    })()\n  }\n\n  throw new TypeError('Body can\\'t be converted to AsyncIterable')\n}\n\n/**\n * Check if it's an AsyncIterable\n */\nconst isAsyncIterable = <TChunk> (value: any): value is AsyncIterable<TChunk> => {\n  return value !== null && typeof value[Symbol.asyncIterator] === 'function'\n}\n\n/**\n * Check for web readable stream\n */\nconst isWebReadableStream = <TChunk> (value: any): value is ReadableStream<TChunk> => {\n  return value != null && typeof value.getReader === 'function'\n}\n\n/**\n * Check for node readable stream\n */\nconst isNodeReadableStream = (value: any): value is Readable =>\n  Object.prototype.hasOwnProperty.call(value, 'readable') &&\n  Object.prototype.hasOwnProperty.call(value, 'writable')\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}