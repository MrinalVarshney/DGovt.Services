{"ast":null,"code":"/* eslint-env browser */\nimport { isMultiaddr } from '@multiformats/multiaddr';\nimport { createKuboRPCClient } from './client.js';\nimport { HTTP } from './lib/http.js';\nexport function create(options = {}) {\n  if (typeof options === 'string' || isMultiaddr(options) || options instanceof URL) {\n    options = {\n      url: options\n    };\n  }\n  return createKuboRPCClient(options);\n}\nexport { CID } from 'multiformats/cid';\nexport { multiaddr } from '@multiformats/multiaddr';\nexport * from './lib/glob-source.js';\nexport function urlSource(url, options) {\n  return {\n    path: decodeURIComponent(new URL(url).pathname.split('/').pop() ?? ''),\n    content: readURLContent(url, options)\n  };\n}\nexport async function* readURLContent(url, options) {\n  const response = await HTTP.get(url, options);\n  yield* response.iterator();\n}\nexport * from './bitswap/index.js';\nexport * from './block/index.js';\nexport * from './bootstrap/index.js';\nexport * from './config/index.js';\nexport * from './dag/index.js';\nexport * from './dht/index.js';\nexport * from './diag/index.js';\nexport * from './files/index.js';\nexport * from './key/index.js';\nexport * from './log/index.js';\nexport * from './name/index.js';\nexport * from './object/index.js';\nexport * from './pin/index.js';\nexport * from './pubsub/index.js';\nexport * from './refs/index.js';\nexport * from './repo/index.js';\nexport * from './routing/index.js';\nexport * from './stats/index.js';\nexport * from './swarm/index.js';","map":{"version":3,"names":["isMultiaddr","createKuboRPCClient","HTTP","create","options","URL","url","CID","multiaddr","urlSource","path","decodeURIComponent","pathname","split","pop","content","readURLContent","response","get","iterator"],"sources":["/home/lokesh/Desktop/DGovt.Services/Hack36_1/client/node_modules/kubo-rpc-client/src/index.ts"],"sourcesContent":["/* eslint-env browser */\n\nimport { isMultiaddr, type Multiaddr } from '@multiformats/multiaddr'\nimport { createKuboRPCClient } from './client.js'\nimport { HTTP } from './lib/http.js'\nimport type { BitswapAPI } from './bitswap/index.js'\nimport type { BlockAPI } from './block/index.js'\nimport type { BootstrapAPI } from './bootstrap/index.js'\nimport type { ConfigAPI } from './config/index.js'\nimport type { DAGAPI } from './dag/index.js'\nimport type { DHTAPI } from './dht/index.js'\nimport type { DiagAPI } from './diag/index.js'\nimport type { FilesAPI } from './files/index.js'\nimport type { KeyAPI } from './key/index.js'\nimport type { HTTPOptions } from './lib/http.js'\nimport type { LoadBaseFn } from './lib/multibases.js'\nimport type { LoadCodecFn } from './lib/multicodecs.js'\nimport type { LoadHasherFn } from './lib/multihashes.js'\nimport type { LogAPI } from './log/index.js'\nimport type { NameAPI } from './name/index.js'\nimport type { ObjectAPI } from './object/index.js'\nimport type { PinAPI } from './pin/index.js'\nimport type { PubSubAPI } from './pubsub/index.js'\nimport type { RefsAPI } from './refs/index.js'\nimport type { RepoAPI } from './repo/index.js'\nimport type { RoutingAPI } from './routing/index.js'\nimport type { StatsAPI } from './stats/index.js'\nimport type { SwarmAPI } from './swarm/index.js'\nimport type { AbortOptions, PeerId } from '@libp2p/interface'\nimport type { Mtime, MtimeLike } from 'ipfs-unixfs'\nimport type { MultibaseCodec } from 'multiformats/bases/interface'\nimport type { CID, Version } from 'multiformats/cid'\nimport type { BlockCodec } from 'multiformats/codecs/interface'\nimport type { MultihashHasher } from 'multiformats/hashes/interface'\nimport type { Agent as HttpAgent } from 'node:http'\nimport type { Agent as HttpsAgent } from 'node:https'\n\nexport type Await<T> = T | Promise<T>\nexport type AwaitIterable<T> = Iterable<T> | AsyncIterable<T>\n\nexport interface HTTPRPCOptions extends AbortOptions {\n  headers?: Headers | Record<string, any>\n  searchParams?: URLSearchParams\n  timeout?: number | string\n  verbose?: boolean\n}\n\nexport interface Bases {\n  getBase(code: string): Promise<MultibaseCodec<any>>\n  listBases(): Array<MultibaseCodec<any>>\n}\n\nexport interface Codecs {\n  getCodec(code: number | string): Promise<BlockCodec<any, any>>\n  listCodecs(): Array<BlockCodec<any, any>>\n}\n\nexport interface Hashers {\n  getHasher(code: number | string): Promise<MultihashHasher>\n  listHashers(): MultihashHasher[]\n}\n\n/**\n * Tracks progress status as a file is transformed into a DAG\n */\nexport interface AddProgressFn { (bytes: number, path?: string): void }\n\ninterface ProgressStatus {\n  total: number\n  loaded: number\n  lengthComputable: boolean\n}\n\n/**\n * Tracks progress status as a file is uploaded to the RPC server\n */\nexport interface UploadProgressFn { (status: ProgressStatus): void }\n\nexport interface EndpointConfig {\n  host: string\n  port: string\n  protocol: string\n  pathname: string\n  'api-path': string\n}\n\nexport interface IPFSEntry {\n  readonly type: 'dir' | 'file'\n  readonly cid: CID\n  readonly name: string\n  readonly path: string\n  mode?: number\n  mtime?: Mtime\n  size: number\n}\n\nexport interface AddOptions extends HTTPRPCOptions {\n  /**\n   * Chunking algorithm used to build ipfs DAGs. (defaults to 'size-262144')\n   */\n  chunker?: string\n  /**\n   * The CID version to use when storing the data\n   */\n  cidVersion?: Version\n\n  /**\n   * Multihash hashing algorithm to use. (Defaults to 'sha2-256')\n   */\n  hashAlg?: string\n\n  /**\n   * If true, will not add blocks to the blockstore. (Defaults to `false`)\n   */\n  onlyHash?: boolean\n\n  /**\n   * Pin this object when adding. (Defaults to `true`)\n   */\n  pin?: boolean\n\n  /**\n   * A function that will be called with the number of bytes added as a file is\n   * added to ipfs and the path of the file being added.\n   *\n   * **Note** It will not be called for directory entries.\n   */\n  progress?: AddProgressFn\n\n  /**\n   * If true, DAG leaves will contain raw file data and not be wrapped in a\n   * protobuf. (Defaults to `false`)\n   */\n  rawLeaves?: boolean\n\n  /**\n   * If true will use the\n   * [trickle DAG](https://godoc.org/github.com/ipsn/go-ipfs/gxlibs/github.com/ipfs/go-unixfs/importer/trickle)\n   * format for DAG generation. (Defaults to `false`).\n   */\n  trickle?: boolean\n\n  /**\n   * Adds a wrapping node around the content. (Defaults to `false`)\n   */\n  wrapWithDirectory?: boolean\n\n  /**\n   * Whether to preload all blocks created during this operation\n   */\n  preload?: boolean\n\n  /**\n   * How many blocks from a file to write concurrently\n   */\n  blockWriteConcurrency?: number\n}\n\nexport interface AddAllOptions extends AddOptions {\n\n  /**\n   * Allows to create directories with an unlimited number of entries currently\n   * size of unixfs directories is limited by the maximum block size.\n   * ** Note ** that this is an experimental feature. (Defaults to `false`)\n   */\n  enableShardingExperiment?: boolean\n\n  /**\n   * Directories with more than this number of files will be created as HAMT -\n   * sharded directories. (Defaults to 1000)\n   */\n  shardSplitThreshold?: number\n\n  /**\n   * How many files to write concurrently\n   */\n  fileImportConcurrency?: number\n}\n\nexport interface AddResult {\n  cid: CID\n  size: number\n  path: string\n  mode?: number\n  mtime?: Mtime\n}\n\nexport interface ShardingOptions {\n  sharding?: boolean\n}\n\nexport interface CatOptions extends HTTPRPCOptions {\n  /**\n   * An offset to start reading the file from\n   */\n  offset?: number\n  /**\n   * An optional max length to read from the file\n   */\n  length?: number\n}\n\nexport interface GetOptions extends HTTPRPCOptions {\n  archive?: boolean\n  compress?: boolean\n  compressionLevel?: -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n}\n\nexport interface ListOptions extends HTTPRPCOptions {\n\n}\n\nexport interface IDOptions extends HTTPRPCOptions {\n  peerId?: PeerId\n}\n\nexport interface IDResult {\n  id: PeerId\n  publicKey: string\n  addresses: Multiaddr[]\n  agentVersion: string\n  protocolVersion: string\n  protocols: string[]\n}\n\n/**\n * An object with the version information for the implementation,\n * the commit and the Repo. `js-ipfs` instances will also return\n * the version of `interface-ipfs-core` and `ipfs-http-client`\n * supported by this node\n */\nexport interface VersionResult {\n  version: string\n  commit?: string\n  repo?: string\n  system?: string\n  golang?: string\n  'ipfs-core'?: string\n  'interface-ipfs-core'?: string\n  'ipfs-http-client'?: string\n}\n\nexport interface PingOptions extends HTTPRPCOptions {\n  count?: number\n}\n\nexport interface PingResult {\n  success: boolean\n  time: number\n  text: string\n}\n\nexport interface ResolveOptions extends HTTPRPCOptions {\n  recursive?: boolean\n  cidBase?: string\n}\n\nexport interface MountOptions extends HTTPRPCOptions {\n  ipfsPath?: string\n  ipnsPath?: string\n}\n\nexport interface MountResult {\n  fuseAllowOther?: boolean\n  ipfs?: string\n  ipns?: string\n}\n\nexport type ImportCandidateStream =\n| AwaitIterable<ImportCandidate>\n| ReadableStream<ImportCandidate>\n\nexport type ImportCandidate =\n  | ToFile\n  | ToDirectory\n  | ToContent\n\nexport interface ToFile extends ToFileMetadata {\n  path?: string\n  content: ToContent\n}\n\nexport interface ToDirectory extends ToFileMetadata {\n  path: string\n  content?: undefined\n}\n\nexport interface ToFileMetadata {\n  mode?: ToMode\n  mtime?: MtimeLike\n}\n\n/**\n * An IPFS path or CID\n */\nexport type IPFSPath = CID | string\n\n/**\n * File content in arbitrary (supported) representation. It is used in input\n * positions and is usually normalized to `Blob` in browser contexts and\n * `AsyncIterable<Uint8Array>` in node.\n */\nexport type ToContent =\n  | string\n  | InstanceType<typeof String>\n  | ArrayBufferView\n  | ArrayBuffer\n  | Blob\n  | AwaitIterable<Uint8Array>\n  | ReadableStream<Uint8Array>\n\nexport type ToMode =\n  | string\n  | number\n\nexport interface KuboRPCClient {\n  bases: Bases\n  codecs: Codecs\n  hashers: Hashers\n  bitswap: BitswapAPI\n  block: BlockAPI\n  bootstrap: BootstrapAPI\n  config: ConfigAPI\n  dag: DAGAPI\n  dht: DHTAPI\n  diag: DiagAPI\n  files: FilesAPI\n  key: KeyAPI\n  log: LogAPI\n  name: NameAPI\n  object: ObjectAPI\n  pin: PinAPI\n  pubsub: PubSubAPI\n  refs: RefsAPI\n  repo: RepoAPI\n  routing: RoutingAPI\n  stats: StatsAPI\n  swarm: SwarmAPI\n\n  /**\n   * Import a file or data into IPFS\n   */\n  add(entry: ImportCandidate, options?: AddOptions): Promise<AddResult>\n\n  /**\n   * Import multiple files and data into IPFS\n   */\n  addAll(source: ImportCandidateStream, options?: AddAllOptions): AsyncIterable<AddResult>\n\n  /**\n   * Returns content of the file addressed by a valid IPFS Path or CID\n   */\n  cat(ipfsPath: IPFSPath, options?: CatOptions): AsyncIterable<Uint8Array>\n\n  /**\n   * Fetch a file or an entire directory tree from IPFS that is addressed by a\n   * valid IPFS Path\n   */\n  get(ipfsPath: IPFSPath, options?: GetOptions): AsyncIterable<Uint8Array>\n\n  /**\n   * Lists a directory from IPFS that is addressed by a valid IPFS Path\n   */\n  ls(ipfsPath: IPFSPath, options?: ListOptions): AsyncIterable<IPFSEntry>\n\n  /**\n   * Returns the identity of the Peer\n   *\n   * @example\n   * ```js\n   * const identity = await ipfs.id()\n   * console.log(identity)\n   * ```\n   */\n  id(options?: IDOptions): Promise<IDResult>\n\n  /**\n   * Returns the implementation version\n   *\n   * @example\n   * ```js\n   * const version = await ipfs.version()\n   * console.log(version)\n   * ```\n   */\n  version(options?: HTTPRPCOptions): Promise<VersionResult>\n\n  /**\n   * Stop the node\n   */\n  stop(options?: HTTPRPCOptions): Promise<void>\n\n  /**\n   * Send echo request packets to IPFS hosts.\n   *\n   * @example\n   * ```js\n   * for await (const res of ipfs.ping('Qmhash')) {\n   *   if (res.time) {\n   *     console.log(`Pong received: time=${res.time} ms`)\n   *   } else {\n   *     console.log(res.text)\n   *   }\n   * }\n   * ```\n   */\n  ping(peerId: PeerId | string, options?: PingOptions): AsyncIterable<PingResult>\n\n  /**\n   * Resolve the value of names to IPFS\n   *\n   * There are a number of mutable name protocols that can link among themselves\n   * and into IPNS. For example IPNS references can (currently) point at an IPFS\n   * object, and DNS links can point at other DNS links, IPNS entries, or IPFS\n   * objects. This command accepts any of these identifiers and resolves them\n   * to the referenced item.\n   *\n   * @example\n   * ```js\n   * // Resolve the value of your identity:\n   * const name = '/ipns/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy'\n   *\n   * const res = await ipfs.resolve(name)\n   * console.log(res)\n   * // Logs: /ipfs/Qmcqtw8FfrVSBaRmbWwHxt3AuySBhJLcvmFYi3Lbc4xnwj\n   *\n   * // Resolve the value of another name recursively:\n   * const name = '/ipns/QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n'\n   *\n   * // Where:\n   * // /ipns/QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n\n   * // ...resolves to:\n   * // /ipns/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n   * // ...which in turn resolves to:\n   * // /ipfs/Qmcqtw8FfrVSBaRmbWwHxt3AuySBhJLcvmFYi3Lbc4xnwj\n   *\n   * const res = await ipfs.resolve(name, { recursive: true })\n   * console.log(res)\n   * // Logs: /ipfs/Qmcqtw8FfrVSBaRmbWwHxt3AuySBhJLcvmFYi3Lbc4xnwj\n   *\n   * // Resolve the value of an IPFS path:\n   * const name = '/ipfs/QmeZy1fGbwgVSrqbfh9fKQrAWgeyRnj7h8fsHS1oy3k99x/beep/boop'\n   * const res = await ipfs.resolve(name)\n   * console.log(res)\n   * // Logs: /ipfs/QmYRMjyvAiHKN9UTi8Bzt1HUspmSRD8T8DwxfSMzLgBon1\n   * ```\n   */\n  resolve(name: string, options?: ResolveOptions): Promise<string>\n\n  /**\n   * Returns a list of available commands\n   */\n  commands(options?: HTTPRPCOptions): Promise<string[]>\n\n  mount(options?: MountOptions): Promise<MountResult>\n\n  /**\n   * Returns true if this IPFS node is online - that is, it's listening on network addresses\n   * for incoming connections\n   */\n  isOnline(): Promise<boolean>\n\n  getEndpointConfig(): EndpointConfig\n}\n\nexport interface Options {\n  host?: string\n  port?: number | string\n  protocol?: string\n  headers?: Headers | Record<string, string>\n  timeout?: number | string\n  apiPath?: string\n  url?: URL | string | Multiaddr\n  ipld?: Partial<IPLDOptions>\n  agent?: HttpAgent | HttpsAgent\n}\n\nexport interface IPLDOptions {\n  loadBase: LoadBaseFn\n  loadCodec: LoadCodecFn\n  loadHasher: LoadHasherFn\n  bases: Array<MultibaseCodec<any>>\n  codecs: Array<BlockCodec<any, any>>\n  hashers: MultihashHasher[]\n}\n\nexport function create (options: string | Multiaddr | URL | Options = {}): KuboRPCClient {\n  if (typeof options === 'string' || isMultiaddr(options) || options instanceof URL) {\n    options = {\n      url: options\n    }\n  }\n\n  return createKuboRPCClient(options)\n}\n\nexport { CID } from 'multiformats/cid'\nexport { multiaddr } from '@multiformats/multiaddr'\nexport * from './lib/glob-source.js'\n\nexport interface UrlSourceEntry {\n  path: string\n  content?: AsyncIterable<Uint8Array>\n}\n\nexport function urlSource (url: string, options?: HTTPOptions): UrlSourceEntry {\n  return {\n    path: decodeURIComponent(new URL(url).pathname.split('/').pop() ?? ''),\n    content: readURLContent(url, options)\n  }\n}\n\nexport async function * readURLContent (url: string, options?: HTTPOptions): AsyncIterable<Uint8Array> {\n  const response = await HTTP.get(url, options)\n\n  yield * response.iterator()\n}\n\nexport * from './bitswap/index.js'\nexport * from './block/index.js'\nexport * from './bootstrap/index.js'\nexport * from './config/index.js'\nexport * from './dag/index.js'\nexport * from './dht/index.js'\nexport * from './diag/index.js'\nexport * from './files/index.js'\nexport * from './key/index.js'\nexport * from './log/index.js'\nexport * from './name/index.js'\nexport * from './object/index.js'\nexport * from './pin/index.js'\nexport * from './pubsub/index.js'\nexport * from './refs/index.js'\nexport * from './repo/index.js'\nexport * from './routing/index.js'\nexport * from './stats/index.js'\nexport * from './swarm/index.js'\n"],"mappings":"AAAA;AAEA,SAASA,WAAW,QAAwB,yBAAyB;AACrE,SAASC,mBAAmB,QAAQ,aAAa;AACjD,SAASC,IAAI,QAAQ,eAAe;AAkepC,OAAM,SAAUC,MAAMA,CAAEC,OAAA,GAA8C,EAAE;EACtE,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIJ,WAAW,CAACI,OAAO,CAAC,IAAIA,OAAO,YAAYC,GAAG,EAAE;IACjFD,OAAO,GAAG;MACRE,GAAG,EAAEF;KACN;EACH;EAEA,OAAOH,mBAAmB,CAACG,OAAO,CAAC;AACrC;AAEA,SAASG,GAAG,QAAQ,kBAAkB;AACtC,SAASC,SAAS,QAAQ,yBAAyB;AACnD,cAAc,sBAAsB;AAOpC,OAAM,SAAUC,SAASA,CAAEH,GAAW,EAAEF,OAAqB;EAC3D,OAAO;IACLM,IAAI,EAAEC,kBAAkB,CAAC,IAAIN,GAAG,CAACC,GAAG,CAAC,CAACM,QAAQ,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,EAAE,IAAI,EAAE,CAAC;IACtEC,OAAO,EAAEC,cAAc,CAACV,GAAG,EAAEF,OAAO;GACrC;AACH;AAEA,OAAO,gBAAiBY,cAAcA,CAAEV,GAAW,EAAEF,OAAqB;EACxE,MAAMa,QAAQ,GAAG,MAAMf,IAAI,CAACgB,GAAG,CAACZ,GAAG,EAAEF,OAAO,CAAC;EAE7C,OAAQa,QAAQ,CAACE,QAAQ,EAAE;AAC7B;AAEA,cAAc,oBAAoB;AAClC,cAAc,kBAAkB;AAChC,cAAc,sBAAsB;AACpC,cAAc,mBAAmB;AACjC,cAAc,gBAAgB;AAC9B,cAAc,gBAAgB;AAC9B,cAAc,iBAAiB;AAC/B,cAAc,kBAAkB;AAChC,cAAc,gBAAgB;AAC9B,cAAc,gBAAgB;AAC9B,cAAc,iBAAiB;AAC/B,cAAc,mBAAmB;AACjC,cAAc,gBAAgB;AAC9B,cAAc,mBAAmB;AACjC,cAAc,iBAAiB;AAC/B,cAAc,iBAAiB;AAC/B,cAAc,oBAAoB;AAClC,cAAc,kBAAkB;AAChC,cAAc,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}