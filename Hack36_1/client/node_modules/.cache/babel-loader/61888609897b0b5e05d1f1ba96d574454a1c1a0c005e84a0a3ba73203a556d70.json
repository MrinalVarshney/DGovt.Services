{"ast":null,"code":"const LOAD_BASE = async name => Promise.reject(new Error(`No base found for \"${name}\"`));\nexport class Multibases {\n  _basesByName;\n  _basesByPrefix;\n  _loadBase;\n  constructor(options) {\n    // Object with current list of active resolvers\n    this._basesByName = {};\n    // Object with current list of active resolvers\n    this._basesByPrefix = {};\n    this._loadBase = options.loadBase ?? LOAD_BASE;\n    // Enable all supplied codecs\n    for (const base of options.bases) {\n      this.addBase(base);\n    }\n  }\n  /**\n   * Add support for a multibase codec\n   */\n  addBase(base) {\n    if (this._basesByName[base.name] != null && this._basesByPrefix[base.prefix] != null) {\n      throw new Error(`Codec already exists for codec \"${base.name}\"`);\n    }\n    this._basesByName[base.name] = base;\n    this._basesByPrefix[base.prefix] = base;\n  }\n  /**\n   * Remove support for a multibase codec\n   */\n  removeBase(base) {\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete this._basesByName[base.name];\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete this._basesByPrefix[base.prefix];\n  }\n  async getBase(nameOrPrefix) {\n    if (this._basesByName[nameOrPrefix] != null) {\n      return this._basesByName[nameOrPrefix];\n    }\n    if (this._basesByPrefix[nameOrPrefix] != null) {\n      return this._basesByPrefix[nameOrPrefix];\n    }\n    // If not supported, attempt to dynamically load this codec\n    const base = await this._loadBase(nameOrPrefix);\n    if (this._basesByName[base.name] == null && this._basesByPrefix[base.prefix] == null) {\n      this.addBase(base);\n    }\n    return base;\n  }\n  listBases() {\n    return Object.values(this._basesByName);\n  }\n}","map":{"version":3,"names":["LOAD_BASE","name","Promise","reject","Error","Multibases","_basesByName","_basesByPrefix","_loadBase","constructor","options","loadBase","base","bases","addBase","prefix","removeBase","getBase","nameOrPrefix","listBases","Object","values"],"sources":["/home/lokesh/Desktop/DGovt.Services/Hack36_1/client/node_modules/kubo-rpc-client/src/lib/multibases.ts"],"sourcesContent":["import type { MultibaseCodec } from 'multiformats/bases/interface'\n\nexport interface LoadBaseFn { (codeOrName: string): Promise<MultibaseCodec<any>> }\n\nconst LOAD_BASE: LoadBaseFn = async (name) => Promise.reject(new Error(`No base found for \"${name}\"`))\n\nexport interface MultibasesInit {\n  loadBase?: LoadBaseFn\n  bases: Array<MultibaseCodec<any>>\n}\n\nexport class Multibases {\n  private readonly _basesByName: Record<string, MultibaseCodec<any>>\n  private readonly _basesByPrefix: Record<string, MultibaseCodec<any>>\n  private readonly _loadBase: LoadBaseFn\n\n  constructor (options: MultibasesInit) {\n    // Object with current list of active resolvers\n    this._basesByName = {}\n\n    // Object with current list of active resolvers\n    this._basesByPrefix = {}\n\n    this._loadBase = options.loadBase ?? LOAD_BASE\n\n    // Enable all supplied codecs\n    for (const base of options.bases) {\n      this.addBase(base)\n    }\n  }\n\n  /**\n   * Add support for a multibase codec\n   */\n  addBase (base: MultibaseCodec<any>): void {\n    if (this._basesByName[base.name] != null && this._basesByPrefix[base.prefix] != null) {\n      throw new Error(`Codec already exists for codec \"${base.name}\"`)\n    }\n\n    this._basesByName[base.name] = base\n    this._basesByPrefix[base.prefix] = base\n  }\n\n  /**\n   * Remove support for a multibase codec\n   */\n  removeBase (base: MultibaseCodec<any>): void {\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete this._basesByName[base.name]\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete this._basesByPrefix[base.prefix]\n  }\n\n  async getBase (nameOrPrefix: string): Promise<MultibaseCodec<any>> {\n    if (this._basesByName[nameOrPrefix] != null) {\n      return this._basesByName[nameOrPrefix]\n    }\n\n    if (this._basesByPrefix[nameOrPrefix] != null) {\n      return this._basesByPrefix[nameOrPrefix]\n    }\n\n    // If not supported, attempt to dynamically load this codec\n    const base = await this._loadBase(nameOrPrefix)\n\n    if (this._basesByName[base.name] == null && this._basesByPrefix[base.prefix] == null) {\n      this.addBase(base)\n    }\n\n    return base\n  }\n\n  listBases (): Array<MultibaseCodec<any>> {\n    return Object.values(this._basesByName)\n  }\n}\n"],"mappings":"AAIA,MAAMA,SAAS,GAAe,MAAOC,IAAI,IAAKC,OAAO,CAACC,MAAM,CAAC,IAAIC,KAAK,CAAC,sBAAsBH,IAAI,GAAG,CAAC,CAAC;AAOtG,OAAM,MAAOI,UAAU;EACJC,YAAY;EACZC,cAAc;EACdC,SAAS;EAE1BC,YAAaC,OAAuB;IAClC;IACA,IAAI,CAACJ,YAAY,GAAG,EAAE;IAEtB;IACA,IAAI,CAACC,cAAc,GAAG,EAAE;IAExB,IAAI,CAACC,SAAS,GAAGE,OAAO,CAACC,QAAQ,IAAIX,SAAS;IAE9C;IACA,KAAK,MAAMY,IAAI,IAAIF,OAAO,CAACG,KAAK,EAAE;MAChC,IAAI,CAACC,OAAO,CAACF,IAAI,CAAC;IACpB;EACF;EAEA;;;EAGAE,OAAOA,CAAEF,IAAyB;IAChC,IAAI,IAAI,CAACN,YAAY,CAACM,IAAI,CAACX,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAACM,cAAc,CAACK,IAAI,CAACG,MAAM,CAAC,IAAI,IAAI,EAAE;MACpF,MAAM,IAAIX,KAAK,CAAC,mCAAmCQ,IAAI,CAACX,IAAI,GAAG,CAAC;IAClE;IAEA,IAAI,CAACK,YAAY,CAACM,IAAI,CAACX,IAAI,CAAC,GAAGW,IAAI;IACnC,IAAI,CAACL,cAAc,CAACK,IAAI,CAACG,MAAM,CAAC,GAAGH,IAAI;EACzC;EAEA;;;EAGAI,UAAUA,CAAEJ,IAAyB;IACnC;IACA,OAAO,IAAI,CAACN,YAAY,CAACM,IAAI,CAACX,IAAI,CAAC;IACnC;IACA,OAAO,IAAI,CAACM,cAAc,CAACK,IAAI,CAACG,MAAM,CAAC;EACzC;EAEA,MAAME,OAAOA,CAAEC,YAAoB;IACjC,IAAI,IAAI,CAACZ,YAAY,CAACY,YAAY,CAAC,IAAI,IAAI,EAAE;MAC3C,OAAO,IAAI,CAACZ,YAAY,CAACY,YAAY,CAAC;IACxC;IAEA,IAAI,IAAI,CAACX,cAAc,CAACW,YAAY,CAAC,IAAI,IAAI,EAAE;MAC7C,OAAO,IAAI,CAACX,cAAc,CAACW,YAAY,CAAC;IAC1C;IAEA;IACA,MAAMN,IAAI,GAAG,MAAM,IAAI,CAACJ,SAAS,CAACU,YAAY,CAAC;IAE/C,IAAI,IAAI,CAACZ,YAAY,CAACM,IAAI,CAACX,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAACM,cAAc,CAACK,IAAI,CAACG,MAAM,CAAC,IAAI,IAAI,EAAE;MACpF,IAAI,CAACD,OAAO,CAACF,IAAI,CAAC;IACpB;IAEA,OAAOA,IAAI;EACb;EAEAO,SAASA,CAAA;IACP,OAAOC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACf,YAAY,CAAC;EACzC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}