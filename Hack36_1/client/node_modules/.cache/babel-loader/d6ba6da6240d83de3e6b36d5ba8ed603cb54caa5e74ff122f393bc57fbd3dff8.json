{"ast":null,"code":"import { createExport } from './export.js';\nimport { createGet } from './get.js';\nimport { createImport } from './import.js';\nimport { createPut } from './put.js';\nimport { createResolve } from './resolve.js';\nexport function createDAG(client, codecs) {\n  return {\n    export: createExport(client),\n    get: createGet(client, codecs),\n    import: createImport(client),\n    put: createPut(client, codecs),\n    resolve: createResolve(client)\n  };\n}","map":{"version":3,"names":["createExport","createGet","createImport","createPut","createResolve","createDAG","client","codecs","export","get","import","put","resolve"],"sources":["/home/lokesh/Desktop/DGovt.Services/Hack36_1/client/node_modules/kubo-rpc-client/src/dag/index.ts"],"sourcesContent":["import { createExport } from './export.js'\nimport { createGet } from './get.js'\nimport { createImport } from './import.js'\nimport { createPut } from './put.js'\nimport { createResolve } from './resolve.js'\nimport type { Codecs, HTTPRPCOptions, IPFSPath } from '../index.js'\nimport type { HTTPRPCClient } from '../lib/core.js'\nimport type { CID, Version } from 'multiformats/cid'\n\nexport interface DAGGetOptions extends HTTPRPCOptions {\n  /**\n   * An optional path within the DAG to resolve\n   */\n  path?: string\n\n  /**\n   * If set to true, it will avoid resolving through different objects\n   */\n  localResolve?: boolean\n}\n\nexport interface DAGGetResult {\n  /**\n   * The value or node that was fetched during the get operation\n   */\n  value: any\n\n  /**\n   * The remainder of the Path that the node was unable to resolve or what was left in a localResolve scenario\n   */\n  remainderPath?: string\n}\n\nexport interface DAGPutOptions extends HTTPRPCOptions {\n  /**\n   * The codec that the input object is encoded with if a pre-encoded object is\n   * supplied.\n   */\n  inputCodec?: string\n\n  /**\n   * The codec that the stored object will be encoded with\n   *\n   * @default 'dag-cbor'\n   */\n  storeCodec?: string\n\n  /**\n   * Multihash hashing algorithm to use\n   *\n   * @default 'sha2-256'\n   */\n  hashAlg?: string\n\n  /**\n   * The version to use to create the CID\n   *\n   * @default 1\n   */\n  version?: Version\n\n  /**\n   * Pin this block when adding\n   *\n   * @default false\n   */\n  pin?: boolean\n\n  /**\n   * If true no blocks will be written to the underlying blockstore\n   */\n  onlyHash?: boolean\n}\n\nexport interface DAGResolveOptions extends HTTPRPCOptions {\n  /**\n   * If ipfsPath is a CID, you may pass a path here\n   */\n  path?: string\n}\n\nexport interface DAGResolveResult {\n  /**\n   * The last CID encountered during the traversal and the path to the end of the IPFS path inside the node referenced by the CID\n   */\n  cid: CID\n\n  /**\n   * The remainder of the Path that the node was unable to resolve\n   */\n  remainderPath?: string\n}\n\nexport interface DAGExportOptions extends HTTPRPCOptions {\n}\n\nexport interface DAGImportOptions extends HTTPRPCOptions {\n  /**\n   * Recursively pin roots for the imported CARs, defaults to true.\n   */\n  pinRoots?: boolean\n}\n\nexport interface DAGImportResult {\n  /**\n   * A list of roots and their pin status if `pinRoots` was set.\n   */\n  root: DAGImportRootStatus\n}\n\nexport interface DAGImportRootStatus {\n  /**\n   * CID of a root that was recursively pinned.\n   */\n  cid: CID\n\n  /**\n   * The error message if the pin was unsuccessful.\n   */\n  pinErrorMsg?: string\n}\n\nexport interface DAGAPI {\n  /**\n   * Retrieve an IPLD format node\n   *\n   * @example\n   * ```js\n   * // example obj\n   * const obj = {\n   *   a: 1,\n   *   b: [1, 2, 3],\n   *   c: {\n   *     ca: [5, 6, 7],\n   *     cb: 'foo'\n   *   }\n   * }\n   *\n   * const cid = await ipfs.dag.put(obj, { storeCodec: 'dag-cbor', hashAlg: 'sha2-256' })\n   * console.log(cid.toString())\n   * // zdpuAmtur968yprkhG9N5Zxn6MFVoqAWBbhUAkNLJs2UtkTq5\n   *\n   * async function getAndLog(cid, path) {\n   *   const result = await ipfs.dag.get(cid, { path })\n   *   console.log(result.value)\n   * }\n   *\n   * await getAndLog(cid, '/a')\n   * // Logs:\n   * // 1\n   *\n   * await getAndLog(cid, '/b')\n   * // Logs:\n   * // [1, 2, 3]\n   *\n   * await getAndLog(cid, '/c')\n   * // Logs:\n   * // {\n   * //   ca: [5, 6, 7],\n   * //   cb: 'foo'\n   * // }\n   *\n   * await getAndLog(cid, '/c/ca/1')\n   * // Logs:\n   * // 6\n   * ```\n   */\n  get(cid: CID, options?: DAGGetOptions): Promise<DAGGetResult>\n\n  /**\n   * Store an IPLD format node\n   *\n   * @example\n   * ```js\n   * const obj = { simple: 'object' }\n   * const cid = await ipfs.dag.put(obj, { storeCodec: 'dag-cbor', hashAlg: 'sha2-512' })\n   *\n   * console.log(cid.toString())\n   * // zBwWX9ecx5F4X54WAjmFLErnBT6ByfNxStr5ovowTL7AhaUR98RWvXPS1V3HqV1qs3r5Ec5ocv7eCdbqYQREXNUfYNuKG\n   * ```\n   */\n  put(node: any, options?: DAGPutOptions): Promise<CID>\n\n  /**\n   * Returns the CID and remaining path of the node at the end of the passed IPFS path\n   *\n   * @example\n   * ```JavaScript\n   * // example obj\n   * const obj = {\n   *   a: 1,\n   *   b: [1, 2, 3],\n   *   c: {\n   *     ca: [5, 6, 7],\n   *     cb: 'foo'\n   *   }\n   * }\n   *\n   * const cid = await ipfs.dag.put(obj, { storeCodec: 'dag-cbor', hashAlg: 'sha2-256' })\n   * console.log(cid.toString())\n   * // bafyreicyer3d34cutdzlsbe2nqu5ye62mesuhwkcnl2ypdwpccrsecfmjq\n   *\n   * const result = await ipfs.dag.resolve(`${cid}/c/cb`)\n   * console.log(result)\n   * // Logs:\n   * // {\n   * //   cid: CID(bafyreicyer3d34cutdzlsbe2nqu5ye62mesuhwkcnl2ypdwpccrsecfmjq),\n   * //   remainderPath: 'c/cb'\n   * // }\n   * ```\n   */\n  resolve(ipfsPath: IPFSPath, options?: DAGResolveOptions): Promise<DAGResolveResult>\n\n  /**\n   * Exports a CAR for the entire DAG available from the given root CID. The CAR will have a single\n   * root and IPFS will attempt to fetch and bundle all blocks that are linked within the connected\n   * DAG.\n   */\n  export(root: CID, options?: DAGExportOptions): AsyncIterable<Uint8Array>\n\n  /**\n   * Import all blocks from one or more CARs and optionally recursively pin the roots identified\n   * within the CARs.\n   */\n  import(sources: Iterable<Uint8Array> | AsyncIterable<Uint8Array> | AsyncIterable<AsyncIterable<Uint8Array>> | Iterable<AsyncIterable<Uint8Array>>, options?: DAGImportOptions): AsyncIterable<DAGImportResult>\n}\n\nexport function createDAG (client: HTTPRPCClient, codecs: Codecs): DAGAPI {\n  return {\n    export: createExport(client),\n    get: createGet(client, codecs),\n    import: createImport(client),\n    put: createPut(client, codecs),\n    resolve: createResolve(client)\n  }\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,aAAa;AAC1C,SAASC,SAAS,QAAQ,UAAU;AACpC,SAASC,YAAY,QAAQ,aAAa;AAC1C,SAASC,SAAS,QAAQ,UAAU;AACpC,SAASC,aAAa,QAAQ,cAAc;AA+N5C,OAAM,SAAUC,SAASA,CAAEC,MAAqB,EAAEC,MAAc;EAC9D,OAAO;IACLC,MAAM,EAAER,YAAY,CAACM,MAAM,CAAC;IAC5BG,GAAG,EAAER,SAAS,CAACK,MAAM,EAAEC,MAAM,CAAC;IAC9BG,MAAM,EAAER,YAAY,CAACI,MAAM,CAAC;IAC5BK,GAAG,EAAER,SAAS,CAACG,MAAM,EAAEC,MAAM,CAAC;IAC9BK,OAAO,EAAER,aAAa,CAACE,MAAM;GAC9B;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}