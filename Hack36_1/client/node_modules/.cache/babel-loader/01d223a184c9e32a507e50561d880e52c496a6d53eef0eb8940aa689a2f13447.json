{"ast":null,"code":"import { createPublish } from './publish.js';\nimport { createPubsub } from './pubsub/index.js';\nimport { createResolve } from './resolve.js';\nexport function createName(client) {\n  return {\n    publish: createPublish(client),\n    resolve: createResolve(client),\n    pubsub: createPubsub(client)\n  };\n}","map":{"version":3,"names":["createPublish","createPubsub","createResolve","createName","client","publish","resolve","pubsub"],"sources":["/home/lokesh/Desktop/DGovt.Services/Hack36_1/client/node_modules/kubo-rpc-client/src/name/index.ts"],"sourcesContent":["import { createPublish } from './publish.js'\nimport { createPubsub, type NamePubSubAPI } from './pubsub/index.js'\nimport { createResolve } from './resolve.js'\nimport type { HTTPRPCOptions } from '../index.js'\nimport type { HTTPRPCClient } from '../lib/core.js'\nimport type { PeerId } from '@libp2p/interface'\nimport type { CID } from 'multiformats/cid'\n\nexport interface NamePublishOptions extends HTTPRPCOptions {\n  /**\n   * Resolve given path before publishing\n   */\n  resolve?: boolean\n  /**\n   * Time duration of the record\n   */\n  lifetime?: string\n  /**\n   * Time duration this record should be cached\n   */\n  ttl?: string\n  /**\n   * Name of the key to be used\n   */\n  key?: string\n  /**\n   * When offline, save the IPNS record\n   * to the the local datastore without broadcasting to the network instead of\n   * simply failing.\n   *\n   * This option is not yet implemented in js-ipfs. See tracking issue [ipfs/js-ipfs#1997]\n   * (https://github.com/ipfs/js-ipfs/issues/1997).\n   */\n  allowOffline?: boolean\n}\n\nexport interface NamePublishResult {\n  /**\n   * The published IPNS name\n   */\n  name: string\n\n  /**\n   * The IPNS record\n   */\n  value: string\n}\n\nexport interface NameResolveOptions extends HTTPRPCOptions {\n  /**\n   * resolve until the result is not an IPNS name\n   */\n  recursive?: boolean\n\n  /**\n   * do not use cached entries\n   */\n  nocache?: boolean\n}\n\nexport interface NameAPI {\n  /**\n   * IPNS is a PKI namespace, where names are the hashes of public keys, and\n   * the private key enables publishing new (signed) values. In both publish\n   * and resolve, the default name used is the node's own PeerID,\n   * which is the hash of its public key.\n   *\n   * @example\n   * ```js\n   * // The address of your files.\n   * const addr = '/ipfs/QmbezGequPwcsWo8UL4wDF6a8hYwM1hmbzYv2mnKkEWaUp'\n   * const res = await ipfs.name.publish(addr)\n   * // You now have a res which contains two fields:\n   * //   - name: the name under which the content was published.\n   * //   - value: the \"real\" address to which Name points.\n   * console.log(`https://gateway.ipfs.io/ipns/${res.name}`)\n   * ```\n   */\n  publish(value: CID | string, options?: NamePublishOptions): Promise<NamePublishResult>\n\n  /**\n   * Given a key, query the DHT for its best value.\n   *\n   * @example\n   * ```js\n   * // The IPNS address you want to resolve\n   * const addr = '/ipns/ipfs.io'\n   *\n   * for await (const name of ipfs.name.resolve(addr)) {\n   *   console.log(name)\n   * }\n   * // Logs: /ipfs/QmQrX8hka2BtNHa8N8arAq16TCVx5qHcb46c5yPewRycLm\n   * ```\n   */\n  resolve(value: PeerId | string, options?: NameResolveOptions): AsyncIterable<string>\n\n  pubsub: NamePubSubAPI\n}\n\nexport function createName (client: HTTPRPCClient): NameAPI {\n  return {\n    publish: createPublish(client),\n    resolve: createResolve(client),\n    pubsub: createPubsub(client)\n  }\n}\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,cAAc;AAC5C,SAASC,YAAY,QAA4B,mBAAmB;AACpE,SAASC,aAAa,QAAQ,cAAc;AAiG5C,OAAM,SAAUC,UAAUA,CAAEC,MAAqB;EAC/C,OAAO;IACLC,OAAO,EAAEL,aAAa,CAACI,MAAM,CAAC;IAC9BE,OAAO,EAAEJ,aAAa,CAACE,MAAM,CAAC;IAC9BG,MAAM,EAAEN,YAAY,CAACG,MAAM;GAC5B;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}