{"ast":null,"code":"import { anySignal } from 'any-signal';\nimport { CID } from 'multiformats/cid';\nimport { multipartRequest } from '../lib/multipart-request.js';\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js';\nexport function createPut(client, codecs) {\n  return async function put(dagNode, options = {}) {\n    const settings = {\n      storeCodec: 'dag-cbor',\n      hashAlg: 'sha2-256',\n      ...options\n    };\n    let serialized;\n    if (settings.inputCodec != null) {\n      // if you supply an inputCodec, we assume you're passing in a raw, encoded\n      // block using that codec, so we'll just pass that on to the server and let\n      // it deal with the decode/encode/store cycle\n      if (!(dagNode instanceof Uint8Array)) {\n        throw new Error('Can only inputCodec on raw bytes that can be decoded');\n      }\n      serialized = dagNode;\n    } else {\n      // if you don't supply an inputCodec, we assume you've passed in a JavaScript\n      // object you want to have encoded using storeCodec, so we'll prepare it for\n      // you if we have the codec\n      const storeCodec = await codecs.getCodec(settings.storeCodec ?? 'dag-cbor');\n      serialized = storeCodec.encode(dagNode);\n      // now we have a serialized form, the server should be told to receive it\n      // in that format\n      settings.inputCodec = settings.storeCodec;\n    }\n    // allow aborting requests on body errors\n    const controller = new AbortController();\n    const signal = anySignal([controller.signal, settings.signal]);\n    try {\n      const res = await client.post('dag/put', {\n        timeout: settings.timeout,\n        signal,\n        searchParams: toUrlSearchParams(settings),\n        ...(await multipartRequest([serialized], controller, settings.headers))\n      });\n      const data = await res.json();\n      return CID.parse(data.Cid['/']);\n    } finally {\n      signal.clear();\n    }\n  };\n}","map":{"version":3,"names":["anySignal","CID","multipartRequest","toUrlSearchParams","createPut","client","codecs","put","dagNode","options","settings","storeCodec","hashAlg","serialized","inputCodec","Uint8Array","Error","getCodec","encode","controller","AbortController","signal","res","post","timeout","searchParams","headers","data","json","parse","Cid","clear"],"sources":["/home/lokesh/Desktop/DGovt.Services/Hack36_1/client/node_modules/kubo-rpc-client/src/dag/put.ts"],"sourcesContent":["import { anySignal } from 'any-signal'\nimport { CID } from 'multiformats/cid'\nimport { multipartRequest } from '../lib/multipart-request.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport type { DAGAPI, DAGPutOptions } from './index.js'\nimport type { Codecs } from '../index.js'\nimport type { HTTPRPCClient } from '../lib/core.js'\n\nexport function createPut (client: HTTPRPCClient, codecs: Codecs): DAGAPI['put'] {\n  return async function put (dagNode, options = {}) {\n    const settings: DAGPutOptions = {\n      storeCodec: 'dag-cbor',\n      hashAlg: 'sha2-256',\n      ...options\n    }\n\n    let serialized\n\n    if (settings.inputCodec != null) {\n      // if you supply an inputCodec, we assume you're passing in a raw, encoded\n      // block using that codec, so we'll just pass that on to the server and let\n      // it deal with the decode/encode/store cycle\n      if (!(dagNode instanceof Uint8Array)) {\n        throw new Error('Can only inputCodec on raw bytes that can be decoded')\n      }\n      serialized = dagNode\n    } else {\n      // if you don't supply an inputCodec, we assume you've passed in a JavaScript\n      // object you want to have encoded using storeCodec, so we'll prepare it for\n      // you if we have the codec\n      const storeCodec = await codecs.getCodec(settings.storeCodec ?? 'dag-cbor')\n      serialized = storeCodec.encode(dagNode)\n      // now we have a serialized form, the server should be told to receive it\n      // in that format\n      settings.inputCodec = settings.storeCodec\n    }\n\n    // allow aborting requests on body errors\n    const controller = new AbortController()\n    const signal = anySignal([controller.signal, settings.signal])\n\n    try {\n      const res = await client.post('dag/put', {\n        timeout: settings.timeout,\n        signal,\n        searchParams: toUrlSearchParams(settings),\n        ...(\n          await multipartRequest([serialized], controller, settings.headers)\n        )\n      })\n      const data = await res.json()\n\n      return CID.parse(data.Cid['/'])\n    } finally {\n      signal.clear()\n    }\n  }\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,YAAY;AACtC,SAASC,GAAG,QAAQ,kBAAkB;AACtC,SAASC,gBAAgB,QAAQ,6BAA6B;AAC9D,SAASC,iBAAiB,QAAQ,gCAAgC;AAKlE,OAAM,SAAUC,SAASA,CAAEC,MAAqB,EAAEC,MAAc;EAC9D,OAAO,eAAeC,GAAGA,CAAEC,OAAO,EAAEC,OAAO,GAAG,EAAE;IAC9C,MAAMC,QAAQ,GAAkB;MAC9BC,UAAU,EAAE,UAAU;MACtBC,OAAO,EAAE,UAAU;MACnB,GAAGH;KACJ;IAED,IAAII,UAAU;IAEd,IAAIH,QAAQ,CAACI,UAAU,IAAI,IAAI,EAAE;MAC/B;MACA;MACA;MACA,IAAI,EAAEN,OAAO,YAAYO,UAAU,CAAC,EAAE;QACpC,MAAM,IAAIC,KAAK,CAAC,sDAAsD,CAAC;MACzE;MACAH,UAAU,GAAGL,OAAO;IACtB,CAAC,MAAM;MACL;MACA;MACA;MACA,MAAMG,UAAU,GAAG,MAAML,MAAM,CAACW,QAAQ,CAACP,QAAQ,CAACC,UAAU,IAAI,UAAU,CAAC;MAC3EE,UAAU,GAAGF,UAAU,CAACO,MAAM,CAACV,OAAO,CAAC;MACvC;MACA;MACAE,QAAQ,CAACI,UAAU,GAAGJ,QAAQ,CAACC,UAAU;IAC3C;IAEA;IACA,MAAMQ,UAAU,GAAG,IAAIC,eAAe,EAAE;IACxC,MAAMC,MAAM,GAAGrB,SAAS,CAAC,CAACmB,UAAU,CAACE,MAAM,EAAEX,QAAQ,CAACW,MAAM,CAAC,CAAC;IAE9D,IAAI;MACF,MAAMC,GAAG,GAAG,MAAMjB,MAAM,CAACkB,IAAI,CAAC,SAAS,EAAE;QACvCC,OAAO,EAAEd,QAAQ,CAACc,OAAO;QACzBH,MAAM;QACNI,YAAY,EAAEtB,iBAAiB,CAACO,QAAQ,CAAC;QACzC,IACE,MAAMR,gBAAgB,CAAC,CAACW,UAAU,CAAC,EAAEM,UAAU,EAAET,QAAQ,CAACgB,OAAO,CAAC;OAErE,CAAC;MACF,MAAMC,IAAI,GAAG,MAAML,GAAG,CAACM,IAAI,EAAE;MAE7B,OAAO3B,GAAG,CAAC4B,KAAK,CAACF,IAAI,CAACG,GAAG,CAAC,GAAG,CAAC,CAAC;IACjC,CAAC,SAAS;MACRT,MAAM,CAACU,KAAK,EAAE;IAChB;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}