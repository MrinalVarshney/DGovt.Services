{"ast":null,"code":"import { CodeError } from '@libp2p/interface';\nimport { CID } from 'multiformats/cid';\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\nfunction isCID(thing) {\n  return CID.asCID(thing) != null;\n}\n/**\n * Transform one of:\n *\n * ```ts\n * CID\n * String\n * { cid: CID recursive, metadata }\n * { path: String recursive, metadata }\n * Iterable<CID>\n * Iterable<String>\n * Iterable<{ cid: CID recursive, metadata }>\n * Iterable<{ path: String recursive, metadata }>\n * AsyncIterable<CID>\n * AsyncIterable<String>\n * AsyncIterable<{ cid: CID recursive, metadata }>\n * AsyncIterable<{ path: String recursive, metadata }>\n * ```\n * Into:\n *\n * ```ts\n * AsyncIterable<{ path: CID|String, recursive:boolean, metadata }>\n * ```\n */\n// eslint-disable-next-line complexity\nexport async function* normaliseInput(input) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw new CodeError(`Unexpected input: ${input}`, 'ERR_UNEXPECTED_INPUT');\n  }\n  // CID\n  const cid = CID.asCID(input);\n  if (cid != null) {\n    yield toPin({\n      cid\n    });\n    return;\n  }\n  if (typeof input === 'string') {\n    yield toPin({\n      path: input\n    });\n    return;\n  }\n  // { cid: CID recursive, metadata }\n  // @ts-expect-error - it still could be iterable or async iterable\n  if (input.cid != null || input.path != null) {\n    // @ts-expect-error cannot derive type\n    return yield toPin(input);\n  }\n  // Iterable<?>\n  if (isIterable(input)) {\n    const iterator = input[Symbol.iterator]();\n    const first = iterator.next();\n    if (first.done === true) {\n      return iterator;\n    }\n    // Iterable<CID>\n    if (isCID(first.value)) {\n      yield toPin({\n        cid: first.value\n      });\n      for (const cid of iterator) {\n        yield toPin({\n          cid\n        });\n      }\n      return;\n    }\n    // Iterable<String>\n    if (typeof first.value === 'string') {\n      yield toPin({\n        path: first.value\n      });\n      for (const path of iterator) {\n        yield toPin({\n          path\n        });\n      }\n      return;\n    }\n    // Iterable<Pinnable>\n    if (first.value.cid != null || first.value.path != null) {\n      yield toPin(first.value);\n      for (const obj of iterator) {\n        yield toPin(obj);\n      }\n      return;\n    }\n    throw new CodeError(`Unexpected input: ${typeof input}`, 'ERR_UNEXPECTED_INPUT');\n  }\n  // AsyncIterable<?>\n  if (isAsyncIterable(input)) {\n    const iterator = input[Symbol.asyncIterator]();\n    const first = await iterator.next();\n    if (first.done === true) return iterator;\n    // AsyncIterable<CID>\n    if (isCID(first.value)) {\n      yield toPin({\n        cid: first.value\n      });\n      for await (const cid of iterator) {\n        yield toPin({\n          cid\n        });\n      }\n      return;\n    }\n    // AsyncIterable<String>\n    if (typeof first.value === 'string') {\n      yield toPin({\n        path: first.value\n      });\n      for await (const path of iterator) {\n        yield toPin({\n          path\n        });\n      }\n      return;\n    }\n    // AsyncIterable<{ cid: CID|String recursive, metadata }>\n    if (first.value.cid != null || first.value.path != null) {\n      yield toPin(first.value);\n      for await (const obj of iterator) {\n        yield toPin(obj);\n      }\n      return;\n    }\n    throw new CodeError(`Unexpected input: ${typeof input}`, 'ERR_UNEXPECTED_INPUT');\n  }\n  throw new CodeError(`Unexpected input: ${typeof input}`, 'ERR_UNEXPECTED_INPUT');\n}\nfunction toPin(input) {\n  const path = input.cid ?? `${input.path}`;\n  if (path == null) {\n    throw new CodeError('Unexpected input: Please path either a CID or an IPFS path', 'ERR_UNEXPECTED_INPUT');\n  }\n  const pin = {\n    path,\n    recursive: input.recursive !== false\n  };\n  if (input.metadata != null) {\n    pin.metadata = input.metadata;\n  }\n  return pin;\n}","map":{"version":3,"names":["CodeError","CID","isIterable","thing","Symbol","iterator","isAsyncIterable","asyncIterator","isCID","asCID","normaliseInput","input","undefined","cid","toPin","path","first","next","done","value","obj","pin","recursive","metadata"],"sources":["/home/lokesh/Desktop/DGovt.Services/Hack36_1/client/node_modules/kubo-rpc-client/src/lib/pins/normalise-input.ts"],"sourcesContent":["import { CodeError } from '@libp2p/interface'\nimport { CID } from 'multiformats/cid'\n\nexport interface Pinnable {\n  path?: string\n  cid?: CID\n  recursive?: boolean\n  metadata?: any\n}\n\nexport type ToPin = CID | string | Pinnable\nexport type Source = ToPin | Iterable<ToPin> | AsyncIterable<ToPin>\n\nexport interface Pin {\n  path: string | CID\n  recursive: boolean\n  metadata?: any\n}\n\nfunction isIterable (thing: any): thing is IterableIterator<any> & Iterator<any> {\n  return Symbol.iterator in thing\n}\n\nfunction isAsyncIterable (thing: any): thing is AsyncIterableIterator<any> & AsyncIterator<any> {\n  return Symbol.asyncIterator in thing\n}\n\nfunction isCID (thing: any): thing is CID {\n  return CID.asCID(thing) != null\n}\n\n/**\n * Transform one of:\n *\n * ```ts\n * CID\n * String\n * { cid: CID recursive, metadata }\n * { path: String recursive, metadata }\n * Iterable<CID>\n * Iterable<String>\n * Iterable<{ cid: CID recursive, metadata }>\n * Iterable<{ path: String recursive, metadata }>\n * AsyncIterable<CID>\n * AsyncIterable<String>\n * AsyncIterable<{ cid: CID recursive, metadata }>\n * AsyncIterable<{ path: String recursive, metadata }>\n * ```\n * Into:\n *\n * ```ts\n * AsyncIterable<{ path: CID|String, recursive:boolean, metadata }>\n * ```\n */\n// eslint-disable-next-line complexity\nexport async function * normaliseInput (input: Source): AsyncGenerator<Pin> {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw new CodeError(`Unexpected input: ${input}`, 'ERR_UNEXPECTED_INPUT')\n  }\n\n  // CID\n  const cid = CID.asCID(input)\n\n  if (cid != null) {\n    yield toPin({ cid })\n    return\n  }\n\n  if (typeof input === 'string') {\n    yield toPin({ path: input })\n    return\n  }\n\n  // { cid: CID recursive, metadata }\n  // @ts-expect-error - it still could be iterable or async iterable\n  if (input.cid != null || input.path != null) {\n    // @ts-expect-error cannot derive type\n    return yield toPin(input)\n  }\n\n  // Iterable<?>\n  if (isIterable(input)) {\n    const iterator = input[Symbol.iterator]()\n    const first = iterator.next()\n\n    if (first.done === true) {\n      return iterator\n    }\n\n    // Iterable<CID>\n    if (isCID(first.value)) {\n      yield toPin({ cid: first.value })\n      for (const cid of iterator) {\n        yield toPin({ cid })\n      }\n      return\n    }\n\n    // Iterable<String>\n    if (typeof first.value === 'string') {\n      yield toPin({ path: first.value })\n      for (const path of iterator) {\n        yield toPin({ path })\n      }\n      return\n    }\n\n    // Iterable<Pinnable>\n    if (first.value.cid != null || first.value.path != null) {\n      yield toPin(first.value)\n      for (const obj of iterator) {\n        yield toPin(obj)\n      }\n      return\n    }\n\n    throw new CodeError(`Unexpected input: ${typeof input}`, 'ERR_UNEXPECTED_INPUT')\n  }\n\n  // AsyncIterable<?>\n  if (isAsyncIterable(input)) {\n    const iterator = input[Symbol.asyncIterator]()\n    const first = await iterator.next()\n    if (first.done === true) return iterator\n\n    // AsyncIterable<CID>\n    if (isCID(first.value)) {\n      yield toPin({ cid: first.value })\n      for await (const cid of iterator) {\n        yield toPin({ cid })\n      }\n      return\n    }\n\n    // AsyncIterable<String>\n    if (typeof first.value === 'string') {\n      yield toPin({ path: first.value })\n      for await (const path of iterator) {\n        yield toPin({ path })\n      }\n      return\n    }\n\n    // AsyncIterable<{ cid: CID|String recursive, metadata }>\n    if (first.value.cid != null || first.value.path != null) {\n      yield toPin(first.value)\n      for await (const obj of iterator) {\n        yield toPin(obj)\n      }\n      return\n    }\n\n    throw new CodeError(`Unexpected input: ${typeof input}`, 'ERR_UNEXPECTED_INPUT')\n  }\n\n  throw new CodeError(`Unexpected input: ${typeof input}`, 'ERR_UNEXPECTED_INPUT')\n}\n\nfunction toPin (input: Pinnable): Pin {\n  const path = input.cid ?? `${input.path}`\n\n  if (path == null) {\n    throw new CodeError('Unexpected input: Please path either a CID or an IPFS path', 'ERR_UNEXPECTED_INPUT')\n  }\n\n  const pin: Pin = {\n    path,\n    recursive: input.recursive !== false\n  }\n\n  if (input.metadata != null) {\n    pin.metadata = input.metadata\n  }\n\n  return pin\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}