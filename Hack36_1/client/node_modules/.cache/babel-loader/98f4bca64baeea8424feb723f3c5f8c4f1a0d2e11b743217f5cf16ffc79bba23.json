{"ast":null,"code":"/**\n * Convert a Node.js [`Writable`](https://nodejs.org/dist/latest/docs/api/stream.html#class-streamwritable)\n * stream to a [sink](https://achingbrain.github.io/it-stream-types/interfaces/Sink.html).\n */\nexport function sink(writable) {\n  return async source => {\n    const maybeEndSource = async () => {\n      if (isAsyncGenerator(source)) {\n        await source.return(undefined);\n      }\n    };\n    let error;\n    let errCb;\n    const errorHandler = err => {\n      error = err;\n      // When the writable errors, try to end the source to exit iteration early\n      maybeEndSource().catch(err => {\n        err = new AggregateError([error, err], 'The Writable emitted an error, additionally an error occurred while ending the Source');\n      }).finally(() => {\n        errCb?.(err);\n      });\n    };\n    let closeCb;\n    let closed = false;\n    const closeHandler = () => {\n      closed = true;\n      closeCb?.();\n    };\n    let finishCb;\n    let finished = false;\n    const finishHandler = () => {\n      finished = true;\n      finishCb?.();\n    };\n    let drainCb;\n    const drainHandler = () => {\n      drainCb?.();\n    };\n    const waitForDrainOrClose = async () => {\n      return new Promise((resolve, reject) => {\n        closeCb = drainCb = resolve;\n        errCb = reject;\n        writable.once('drain', drainHandler);\n      });\n    };\n    const waitForDone = async () => {\n      // Immediately try to end the source\n      await maybeEndSource();\n      return new Promise((resolve, reject) => {\n        if (closed || finished || error != null) {\n          resolve();\n          return;\n        }\n        finishCb = closeCb = resolve;\n        errCb = reject;\n      });\n    };\n    const cleanup = () => {\n      writable.removeListener('error', errorHandler);\n      writable.removeListener('close', closeHandler);\n      writable.removeListener('finish', finishHandler);\n      writable.removeListener('drain', drainHandler);\n    };\n    writable.once('error', errorHandler);\n    writable.once('close', closeHandler);\n    writable.once('finish', finishHandler);\n    try {\n      for await (const value of source) {\n        if (!writable.writable || writable.destroyed || error != null) {\n          break;\n        }\n        if (!writable.write(value)) {\n          await waitForDrainOrClose();\n        }\n      }\n    } catch (err) {\n      // error is set by stream error handler so only destroy stream if source\n      // threw\n      if (error == null) {\n        writable.destroy(err);\n      }\n      // could we be obscuring an error here?\n      error = err;\n    }\n    try {\n      // We're done writing, end everything (n.b. stream may be destroyed at this\n      // point but then this is a no-op)\n      if (writable.writable) {\n        writable.end();\n      }\n      // Wait until we close or finish. This supports halfClosed streams\n      await waitForDone();\n      // Notify the user an error occurred\n      if (error != null) throw error;\n    } finally {\n      // Clean up listeners\n      cleanup();\n    }\n  };\n}\nfunction isAsyncGenerator(obj) {\n  return obj.return != null;\n}","map":{"version":3,"names":["sink","writable","source","maybeEndSource","isAsyncGenerator","return","undefined","error","errCb","errorHandler","err","catch","AggregateError","finally","closeCb","closed","closeHandler","finishCb","finished","finishHandler","drainCb","drainHandler","waitForDrainOrClose","Promise","resolve","reject","once","waitForDone","cleanup","removeListener","value","destroyed","write","destroy","end","obj"],"sources":["/home/lokesh/Desktop/DGovt.Services/Hack36_1/client/node_modules/stream-to-it/src/sink.ts"],"sourcesContent":["import type { Sink, Source } from 'it-stream-types'\nimport type { Writable } from 'node:stream'\n\n/**\n * Convert a Node.js [`Writable`](https://nodejs.org/dist/latest/docs/api/stream.html#class-streamwritable)\n * stream to a [sink](https://achingbrain.github.io/it-stream-types/interfaces/Sink.html).\n */\nexport function sink <T> (writable: Writable): Sink<Source<T>, Promise<void>> {\n  return async (source: Source<T>): Promise<void> => {\n    const maybeEndSource = async (): Promise<void> => {\n      if (isAsyncGenerator(source)) {\n        await source.return(undefined)\n      }\n    }\n\n    let error: Error | undefined\n    let errCb: ((err: Error) => void) | undefined\n    const errorHandler = (err: Error): void => {\n      error = err\n\n      // When the writable errors, try to end the source to exit iteration early\n      maybeEndSource()\n        .catch(err => {\n          err = new AggregateError([\n            error,\n            err\n          ], 'The Writable emitted an error, additionally an error occurred while ending the Source')\n        })\n        .finally(() => {\n          errCb?.(err)\n        })\n    }\n\n    let closeCb: (() => void) | undefined\n    let closed = false\n    const closeHandler = (): void => {\n      closed = true\n      closeCb?.()\n    }\n\n    let finishCb: (() => void) | undefined\n    let finished = false\n    const finishHandler = (): void => {\n      finished = true\n      finishCb?.()\n    }\n\n    let drainCb: (() => void) | undefined\n    const drainHandler = (): void => {\n      drainCb?.()\n    }\n\n    const waitForDrainOrClose = async (): Promise<void> => {\n      return new Promise<void>((resolve, reject) => {\n        closeCb = drainCb = resolve\n        errCb = reject\n\n        writable.once('drain', drainHandler)\n      })\n    }\n\n    const waitForDone = async (): Promise<void> => {\n      // Immediately try to end the source\n      await maybeEndSource()\n\n      return new Promise<void>((resolve, reject) => {\n        if (closed || finished || (error != null)) {\n          resolve()\n          return\n        }\n\n        finishCb = closeCb = resolve\n        errCb = reject\n      })\n    }\n\n    const cleanup = (): void => {\n      writable.removeListener('error', errorHandler)\n      writable.removeListener('close', closeHandler)\n      writable.removeListener('finish', finishHandler)\n      writable.removeListener('drain', drainHandler)\n    }\n\n    writable.once('error', errorHandler)\n    writable.once('close', closeHandler)\n    writable.once('finish', finishHandler)\n\n    try {\n      for await (const value of source) {\n        if (!writable.writable || writable.destroyed || (error != null)) {\n          break\n        }\n\n        if (!writable.write(value as any)) {\n          await waitForDrainOrClose()\n        }\n      }\n    } catch (err: any) {\n      // error is set by stream error handler so only destroy stream if source\n      // threw\n      if (error == null) {\n        writable.destroy(err)\n      }\n\n      // could we be obscuring an error here?\n      error = err\n    }\n\n    try {\n      // We're done writing, end everything (n.b. stream may be destroyed at this\n      // point but then this is a no-op)\n      if (writable.writable) {\n        writable.end()\n      }\n\n      // Wait until we close or finish. This supports halfClosed streams\n      await waitForDone()\n\n      // Notify the user an error occurred\n      if (error != null) throw error\n    } finally {\n      // Clean up listeners\n      cleanup()\n    }\n  }\n}\n\nfunction isAsyncGenerator <T = any> (obj?: any): obj is AsyncGenerator<T> {\n  return obj.return != null\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}